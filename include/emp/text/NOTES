Emphatic is an internal coding for Empirical that will try to support as many text encodings as reasonable, simplifying the conversion between them while being easy to write to in code (via the emp::Text object.)

Supported text formats:
 TXT (plain text - working)
 HTML (simple tags working)
 LATEX
 MARKDOWN (need to be careful that C++, for example, doesn't grab the '++')
 RTF
 XML
 MarkBack (custom markup language; simple tags working)

Internal encoding (Emphatic)
 The Emphatic encoding maintains a string of characters, each associated with any number of styles.  The standard styles are:
  bold
  code
  comment (text that should not be shown in final output)
  italic
  strike (for strikethrough)
  subscript
  superscript
  underline

 Some styles are only associated with individual special characters (usually matched with a space).  This are:
  no_break - non-breaking space
  bullet
  ordered
  indent
  blockquote - Marks this line as being part of a blockquote.

 Additional styles are followed by a colon and details must be provided.
  header - followed by header level (e.g.: header:1)
  link - text should redirect to provided URL (e.g.: link:https://google.com)
  image - followed by location of image.



---------------------------------------


MarkBack notes:
  New format is .mback, which is inspired by markdown, but uses just two types of special characters for formatting control:
     Backquotes (`) indicate a change in text STYLE
     Backslashes (\) indicate an insertion (e.g., an emoji or a bullet)
  Everything else is direct text, so you should never have surprises in the final formatting.

  The following tags toggle a formatting STYLE.

   `*Bold!`*
   ``Code``
   `/Italic`/
   `_Underlined!`_
   `^Superscript`^
   `.Subscript`.
   `~Strikethrough`~
   `<Left Justified`<
   `>Right Justified`>
   `|Fully Justified`|
   `=Centered`=

  Some types require extra details:

   `@{URL}Linked-text goes here`@
   `[blue]This text would be blue
   `[#FF00FF]This text would be magenta
   `[]This text would be back to default color.

  You can end ALL special formatting with `!

  Code -- see below.
   `{var name=value or other_code}
   `?{TEST}Optional formatting  -- e.g., ?{has_error}[red] or ?{important}*

  The following tags change the format for the rest of the line they are on:

   `" Blockquote (Should be the first non-whitespace, or a preceding newline will be assumed)
   `% Comment that will be removed
   `# Heading format
   `## Heading level 2
   `### etc. deeper headings.
   `- Ignore all special formatting for the rest of the line
   `: Continues the previous line for other tags in this group (should be first non-whitespace)

  Anything with three backticks (```) before and after will be treated as code blocks.

  A single or double backtick indicates that everything in between is going to be inline
  code.  A single backtick must be followed by an alphanumeric character or whitespace,
  but a double backtick can be followed by anything EXCEPT another backtick or backslash,
  which still have special meanings.

   `This would be rendered as CODE`
   ``{This would also be rendered as code, _with_ the braces appearing}``

  A triple backtick starts a coding region.  The remainder of the line specifies format.
  Subsequent lines are assumed to be code and ALL characters are allowed until a final
  line is reached with just a ``` on that line and nothing else except whitespace.

   ```cpp
   CPPFunctionCall(x, y);
   ```

  Unused symbols for style: $&()+;',
  ALSO technically unused, but less useful: ]}

  The following tags handle special CHARACTERS:

   \\ is a regular backslash ('\')
   \` is a regular backtick ('`')
   \_ is a non-breaking space.
   \b is a page break
   \n is a line break (newline)
   \p is a paragraph break
   \t is a tab

  For inserting entries into bulleted lists you can use:
   \* is a simple bullet for a list entry
   \+ is a numerical bullet, incrementing if in a list
   \a is a lowercase alphabetic bullet, incrementing if in a list
   \A is an uppercase alphabetic bullet, incrementing if in a list
   \o task-list bullet (i.e., a checkbox)
   \R is a roman numeral bullet, incrementing if in a list
   \={123} (or any other numbers or letters) is a specified value for a bullet (a subsequent \+, \a, or \R will continue from it)
  Note that initial bullet symbols can be repeated any number of times for deeper indentation and nested lists.
  For example \***, \++, or \===={123}

  Other special insertions are also possible with backslash:
   \#{hashtag}
   \| is the beginning of a line for creating a table (rest of line is markdown format...?)
   \. is nothing. Use to separate other text (e.g., for unicode immediately followed by a number)
   \- is a horizontal rule
   \^{note} creates an footnote.  This is a superscript value with the contents included at the end of the page (or end of document if no page breaks)
   \d{name} creates a division with a specified name
   \(URL) or \(#hashtag) will place a link this point WITH itself as the text
   \[URL|width=100,height=200,alt="my image!"] will RESOLVE a URL to an image and place it here
   \:name: or \:{name} will place the emoji associated with 'name' (or unicode character if a number is used)

  For easier HTML conversion, we also have the ability to simply escape existing HTML text:
   \<tag> tries to match the associated HTML tag
   \&name; or \&{name} insert a character by a given HTML name (unicode works same as HTML)

  For embedded code:
   \{var_value_printed_here} - see below
   \?{TEST}{Optional text} - insert only if TEST is true.


  Unused symbols for insertions: $~!@%;'",/ plus lots of letters
  ALSO technically unused, but less useful: ]>})


  Now for the crazy.  We can EMBED CODE as needed.

   `{var name=value or other_code}
   \{var_value_printed_here}
   `?{TEST}Optional formatting  -- e.g., ?{has_error}[red] or ?{important}*
   \?{TEST}{Optional text} - insert only if TEST is true.


MARKBACK CODE:
Can view context?
- Line it is at
- File it is in
- Rendered to format???
- Time / Date?
- Hashtags??
- Current Div?
- #include ?



Some saved notes:
    // Tag layout differs substantially from one language to the next.  For example, to make
    // text have the style "bold", it may look like:
    //   HTML:      One word is <b>bold</b>.
    //   MarkDown:  One word is *bold*.
    //   LaTeX:     One word is \textbf{bold}.
    //   MarkBack:  One word is `*bold`*
    //
    // Some styles need to have arguments associated with them.  For example, a heading needs
    // to have a level.  A level 3 heading, for example, would be stored as style "heading:3".
    //   HTML:      <h3>A level 3 heading</h3>
    //   MarkDown:  ### A level 3 heading
    //   LaTeX:     \subsubsection{A level 3 heading}
    //   MarkBack:  `### A level 3 heading
    //
    // The patterns associated with these can either be broken up into multiple tags (for example,
    // in LaTeX it's easier to match a specific "\subsubsection{" open tag with "header:3" style),
    // while HTML can use the pattern "H$d" mapping to "header:$0".  In Markdown we would use
    // "$r{#}" mapping to "header:$0"
    //
    // Finally, more complex tags are possible.  For example, if a tag is supposed to map a
    // series of words to a linked URL:
    //   HTML:      This is <a href="http://www.exmaple.com/">linked</a> text.
    //   MarkDown:  This is [linked](http://www.exmaple.com/) text.
    //   LaTeX:     This is \href{http://www.exmaple.com/}{linked} text.
    //   MarkBack:  This is `[linked](http://www.exmaple.com/) text.
    //
    // For these patterns, HTML open would look like: <a href="%u">
    // And it would be set to the style: "link:$0".

Original comments on tag pattern:
      // What pattern will identify this tag?  Any characters EXCEPT $ will be taken literally.
      // $$ will be a single $.  A $ followed by a letter will have a specific meaning.
      //   $d = A single digit (0 to 9)
      //   $f = Any filename (includes a-z, A-Z, 0-9, '_', '/', '.', and '-')
      //   $i = Any identifier sequence (includes a-z, A-Z, 0-9 and '_')
      //   $n = Any whole number sequence (a series of digits)
      //   $r{pattern} = A repeated pattern
      //   @CAO FUTURE ADDITION: $t = Any normal text
      //   $u = Any URL

For style replacements:
      // A more complex style uses a replacement pattern to generate its description.  It can use $0
      // through $9 for the $letter material in the pattern. (e.g., a font should track the
      // name of the font.)

And for converting a pattern to a normal regex:
```cpp
      std::string AsRegEx() {
        std::string out;
        for (size_t i = 0; i < pattern.size(); ++i) {
          if (pattern[i] == '$') {
            ++i;
            emp_assert(i < pattern.size());
            switch (pattern[i]) {
              case '$': out += "$"; break;
              case 'd': out += "[0-9]"; break;
              case 'f': out += "[a-zA-Z0-9_/.-]+"; break;
              case 'i': out += "[a-zA-Z0-9_]+"; break;
              case 'n': out += "[0-9]+"; break;
              case 'r':
                {
                  size_t start = i;
                  i = emp::find_paren_match(pattern, i, '{', '}', false);
                  out += "\"" + pattern.substr(start+1, i-start-1) + "\"+";
                }
                break;
              case 't': out += "[]"; break;
              case 'u': out += "[a-zA-Z0-9_/.+:-]"; break;
            }
          }
          else if (pattern[0] == '[') out += "[\\[]";
          else if (pattern[0] == ']') out += "[\\]]";
          else if (pattern[0] == '*') out += "[*]";
          else if (pattern[0] == '.') out += "[.]";
          else if (pattern[0] == '+') out += "[+]";
          else if (pattern[0] == '?') out += "[?]";
          else if (pattern[0] == '|') out += "[|]";
          else if (pattern[0] == '(') out += "[()]";
          else if (pattern[0] == ')') out += "[)]";
          else out += pattern[i];
        }
        return out;
      }
```
