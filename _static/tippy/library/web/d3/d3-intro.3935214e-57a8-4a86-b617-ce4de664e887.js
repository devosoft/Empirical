selector_to_html = {"a[href=\"#css-file\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">CSS File<a class=\"headerlink\" href=\"#css-file\" title=\"Link to this heading\">\uf0c1</a></h3><p>Optionally, a CSS file can be used to make elements look the way you\nwant them to. Here\u2019s one that includes the necessary styles to make\ntooltips work (the html file above assumes it\u2019s called\nstyle_sheet.css, and is in the same directory as the html file):</p>", "a[href=\"#running-your-visualization\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Running your visualization<a class=\"headerlink\" href=\"#running-your-visualization\" title=\"Link to this heading\">\uf0c1</a></h3><p>Now to open up the page in a browser! Some browsers will let you open\nthe page up directly, but some will complain about the fact that you\u2019re\ntrying to access a file on your computer (example.json) with Javascript.\nThe easiest way around this is with the Python simpleHTTPServer library.\nIf you\u2019re using Python 2.x, run the following command from the\ndirectory containing your html file:</p>", "a[href=\"#a-minimal-example\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">A Minimal Example<a class=\"headerlink\" href=\"#a-minimal-example\" title=\"Link to this heading\">\uf0c1</a></h2><p>D3 visualizations run in web browsers. That means that to use this\nwrapper, you need to compile your C++ code to Javascript, using\nEmscripten. To see the visualization, you need to have an html file that\nloads your Javascript. Then you need to open that html file in a web\nbrowser. Optionally, you might also have a CSS file that contains rules\nfor how elements of your web page should look.</p><p>This example assumes the following file structure:</p>", "a[href=\"#binding-data\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Binding Data<a class=\"headerlink\" href=\"#binding-data\" title=\"Link to this heading\">\uf0c1</a></h3><p>In D3, you bind data to selections. Usually, you are binding that data\nbecause you to visualize it with SVG elements. So, usually the selection\nthat we\u2019re binding data to is a selection of some type of SVG element\non an SVG canvas. Something like this:</p>", "a[href=\"#passing-functions-as-arguments\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Passing Functions as Arguments<a class=\"headerlink\" href=\"#passing-functions-as-arguments\" title=\"Link to this heading\">\uf0c1</a></h2><p>In Javascript, it\u2019s very common to pass functions as arguments to other\nfunctions in order to customize their behavior. This comes, in part,\nfrom the fact that a lot of Javascript code is exectured asynchronously.\nSince the goal of most Javscript is to run a web page, Javascript needs\nto respond to events such as user interactions (clicking, scrolling,\netc.). It also needs to avoid delaying everything on the page just\nbecause there\u2019s a picture it\u2019s trying to load from a server that\u2019s\ndown. As a result, functions that require waiting for something to\nhappen often accept a \u201ccallback function\u201d as an argument. This\nfunction will get run when the function it was passed to is done. This\nway of programming can take some getting used to for people who are more\nused to more linear programming languages, but it\u2019s hard to avoid when\nwriting web code.</p><p>D3.js makes heavy use of functions-as-arguments. Most commonly, this\nhappens when you\u2019re trying to set attributes of graphical elements\nbased on the data that is bound to them (as demonstrated in the section\non binding data); you pass a function that takes a piece of data as an\nargument and returns the attribute value.</p>", "a[href=\"#transitions\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Transitions<a class=\"headerlink\" href=\"#transitions\" title=\"Link to this heading\">\uf0c1</a></h2><p>One of the most powerful parts of D3 is the ease with which it allows\nyou to animate your data. This is accomplished with\n<code class=\"docutils literal notranslate\"><span class=\"pre\">transitions</span> <span class=\"pre\">&lt;Selections_and_Transitions_API&gt;</span></code>{.interpreted-text\nrole=\u201dref\u201d}. The most common way to make a transition is to call the\n[selection.MakeTransition()]{.title-ref} method on a selection\ncontaining all of the elements you want to animate (note: in Javascript,\nthe method is just selection.transition(), because Javascript is less\nfinicky about name collisions). You can then use the\n[attr()]{.title-ref} and [style()]{.title-ref} methods on the\ntransition, just as you would on a selection, and the change will be\nanimated. Note that the wrapper also allows you to set properties, html,\nand classes on a transition, but D3 doesn\u2019t know how to animate changes\nin these, so they will just happen at the end of the transition. Other\noperations, such as appending new elements, are not allowed on\ntransitions, because there isn\u2019t a clear way to animate them.</p><p>For instance, here\u2019s an example of animating a circle moving across the\nscreen and gradually changing color from black (default) to blue:</p>", "a[href=\"#writing-your-own-visualization\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Writing Your Own Visualization<a class=\"headerlink\" href=\"#writing-your-own-visualization\" title=\"Link to this heading\">\uf0c1</a></h2><p>To build your own visualization, you need to understand a bit about how\nD3 works. Which means you need to understand a bit about how Javascript\nand HTML work. I know, I know, the reason you\u2019re doing this all in C++\nis that you want to avoid that, but I promise it\u2019s worth it if you want\nto make interactive visualizations that run on the web.</p><p>When your browser loads a website, it takes the html for that page and\nturns it into a tree:</p>", "a[href=\"#c-file\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">C++ File<a class=\"headerlink\" href=\"#c-file\" title=\"Link to this heading\">\uf0c1</a></h3><p>The C++ file that you\u2019ll compile to Javascript. For this example,\nwe\u2019ll use the Empirical web module to build the whole web page:</p>", "a[href=\"#html-file\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">HTML File<a class=\"headerlink\" href=\"#html-file\" title=\"Link to this heading\">\uf0c1</a></h3><p>To tell the browser what to do with your Javascript, you need an html\nfile:</p>", "a[href=\"#selections\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Selections<a class=\"headerlink\" href=\"#selections\" title=\"Link to this heading\">\uf0c1</a></h3><p><code class=\"docutils literal notranslate\"><span class=\"pre\">Selections</span> <span class=\"pre\">&lt;Selections_and_Transitions_API&gt;</span></code>{.interpreted-text\nrole=\u201dref\u201d} are a way to work with groups of DOM elements. For instance,\nlet\u2019s say we have this html file:</p>", "a[href=\"#changing-elements-traits\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Changing Elements\u2019 Traits<a class=\"headerlink\" href=\"#changing-elements-traits\" title=\"Link to this heading\">\uf0c1</a></h3><p>There are three types of traits that a DOM element might have:\nattributes, styles, and properties. For the most part, attributes are\nfundamental pieces of information about the element, styles deal with\nthe element\u2019s appearance (they are all things you could set with CSS),\nand properties are rare and specific to certain types of elements. The\ndistinction mostly only matters because it determines which functions\nyou call to set and get the values of a trait. Here are some examples of\ncommonly used traits in each category:</p><p><strong>Attributes (use SetAttr()):</strong></p>", "a[href=\"#using-empirica-s-d3-js-wrapper\"]": "<h1 class=\"tippy-header\" style=\"margin-top: 0;\">Using Empirica\u2019s D3.js Wrapper<a class=\"headerlink\" href=\"#using-empirica-s-d3-js-wrapper\" title=\"Link to this heading\">\uf0c1</a></h1><p>If you\u2019re writing scientific code that runs on the web, you\u2019ll\nprobably want to visualize the results (either as your program runs or\nafter it\u2019s done). To make this as easy as possible, Empirical includes\na C++ wrapper for d3.js, a wildly popular and powerful Javascript data\nvisualization library. Using the wrapper, you can create visualizations\ndirectly from C++.</p><p>At a base level, the wrapper provides C++ equivalents for all objects,\nmethods, and functions in d3.js. So, if you\u2019re used to using d3, using\nthe wrapper should be very similar. However, d3.js is a library that you\nuse to build visualizations rather than a library of pre-built\nvisualizations (a fact that has lead to the proliferation of many very\nsimilar libraries built on top of d3 that provide pre-built graphs).\nWhere possible, we have tried to provide short-cut functions and\npre-built graph objects in an effort to help those new to Javascript\nvisualization get started fast. This is an ongoing process and we\u2019re\nalways open to suggestions!</p>", "a[href=\"#under-the-hood-for-the-curious-developers-and-people-trying-to-do-weird-stuff\"]": "<h2 class=\"tippy-header\" style=\"margin-top: 0;\">Under the Hood (for the curious, developers, and people trying to do weird stuff)<a class=\"headerlink\" href=\"#under-the-hood-for-the-curious-developers-and-people-trying-to-do-weird-stuff\" title=\"Link to this heading\">\uf0c1</a></h2><p>For the most part, Empirical\u2019s d3 wrapper isn\u2019t that complicated under\nthe hood. All C++ objects in the d3 module have a unique integer id.\nMost of them don\u2019t actually store much more information. Instead, they\nserve as an interface to an object stored in Javascript. All Javascript\nobjects that are being represented in C++ are stored in a Javascript\narray called [js.objects]{.title-ref}. An object\u2019s id is actually the\nindex of the corresponding Javascript object in the\n[js.objects]{.title-ref} array. Methods of that object reach into\nJavascript and call the corresponding method on the appropriate object.\nSome higher-level functions may call more than one d3 function.</p><p>The other piece of complexity that is hidden from the user is the\ntranslation between JSON objects in Javascript and objects created with\nEMP_BUILD_INTROSPECTIVE_TUPLE. This is all handled by\n<code class=\"docutils literal notranslate\"><span class=\"pre\">JSWrap</span> <span class=\"pre\">&lt;JSWrap&gt;</span></code>{.interpreted-text role=\u201dref\u201d}, which identifies\nobjects created with EMP_BUILD_INTROSPECTIVE_TUPLE by looking for a\nmember called n_fields. n_fields is created by\nEMP_BUILD_INTROSPECTIVE_TUPLE and indicates how many fields an object\nhas. All conversion from C++ functions to javascript functions is\nhandled by JSWrap (if you pass a function directly to a d3 method,\nJSWrap is called behind the scenes). This is why it is potentially more\nefficient to wrap functions once and pass the Javascript name as a\nstring than to keep passing them as C++ functions and re-wrapping them\nevery time. Rigorous tests on how much of a slow-down this introduces\nhave not been conducted.</p>", "a[href=\"#scales-and-axes\"]": "<h3 class=\"tippy-header\" style=\"margin-top: 0;\">Scales and Axes<a class=\"headerlink\" href=\"#scales-and-axes\" title=\"Link to this heading\">\uf0c1</a></h3><p>Usually your data is not in units that you can directly draw on the\nscreen. For instance, if you want to plot a variable on the Y axis that\nhas values from -1 to 1, you\u2019ll need a way to convert from these very\nsmall values to values representing where the elements of your\nvisualization should appear on the SVG canvas (in pixels). This is what\n<code class=\"docutils literal notranslate\"><span class=\"pre\">scales</span> <span class=\"pre\">&lt;Scales_API&gt;</span></code>{.interpreted-text role=\u201dref\u201d} do. Like a number of\nother objects in D3, scales are actually functions. They accept a value\nin the domain (the range of values your data can have) and return a\nvalue in the range (the range of coordinates on your screen that you\nwant data to show up in).</p><p>For example, lets say we have data ranging from 0 to 1 and we want to\nconvert it to coordinates on our screen from 0 to 100. We can make a\nscale to do it:</p>"}
skip_classes = ["headerlink", "sd-stretched-link"]

window.onload = function () {
    for (const [select, tip_html] of Object.entries(selector_to_html)) {
        const links = document.querySelectorAll(` ${select}`);
        for (const link of links) {
            if (skip_classes.some(c => link.classList.contains(c))) {
                continue;
            }

            tippy(link, {
                content: tip_html,
                allowHTML: true,
                arrow: true,
                placement: 'auto-start', maxWidth: 500, interactive: false,

            });
        };
    };
    console.log("tippy tips loaded!");
};
