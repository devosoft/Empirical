-= Next Steps =-
Setup Config class to << into Slate to produce settings management
Implement TubeCode in Hardware class
Setup documentation outside of the code

-= Questions =-
Best way to convert to a c++ literal independent of type?
How to dynamically change an include file?

-= Fixes =-
Fix reference counting in C++ DOM trees to delete element if ONLY children are pointing to it.
JSDelete should make sure that we are not deleting a named function (or cleanup JS side too!)
Fix how is_valid() functions are handled in string_utils.h

-= Improvements =-
Tables need more natural interface that should behave like a slate.
std::endl should work on TextBox
Tables should have single CSS for all rows and all cells.
Allow default UI::Style overall and for each object type.
-Create a UI::StyleGroup that elements can be added to and altered as one (use proper CSS class?)
Base document should register where keypresses should be directed.
-Buttons should be able to easily specify hotkeys
BitSet should have a non-emscripten version that uses 64-bits (same as BitVector)
- Incorporate Ben's changes into BitVector/BitSet
Setup a disabled_CSS for buttons that they apply when disabled?
Allow Widgets to be removed from slates (and deactivated, slate redrawn, etc.)

-= Improvements to Consider =-
Try out Ptr class to see if it can catch mis-handled pointers
Slates should have a current location and always "append" at that location, not just at end.
- Forwarding to a parent should track where the forward came from to update location information.
InstLib: Can we lock a set of instruction at compile time?  Or at least put them in a fixed array?
Change HardwareCPU to something like Hardware_SimpleCPU and Instruction to Instruction_SimpleCPU

-= New Elements =-
Forms
JQuerryUI Tabs?
Span (?) for future manual references
Dynamic web link? (Easy to change and verify, rather than embeded in text.)

-= General tools to build =-
A more automated test system (Try out "Catch"?)
A data management system that can track data by:
  - Temporal series (values over time)
  - Batch (where a batch reset occurs periodically)
  - Log (tracking particular events when they occur)
  All output files should have headers that allow them to be read back in more easily.
A citation tool: Useful for pointing people to appropriate references & building online bibs.

-= Serialization =-
Special mechanisms to handle pointers of various types:
- Pointers we are in charge of and need to build.
- Pointers we are NOT in charge of and someone else needs to expliclty build
- Pointers we are not in charge of because they are objects built elsewhere.

-= Evolution-specific Tools =-
Organism Object (Contains Genome and templated on virtual hardware type)
Genotype manager (for organisms with identical genomes)
Phenotype summary to include in the genotype
Phylogeny/lineage manager with multiple modes of purging (and link to phenotypes?)
Clade manager that will mark into phenotypes which clades they are associated with

-= Optimizations to Explore =-
Should quick-lookup for sin, cos, tan be at higher resolution (now it's 256 entires)?
Fix how sectors are handled in surfaces to be more dynamic based on sizes of organisms.
- Consider sorting organisms by size and processing smallest first?
  Then any particular comparison is only up against as small or smaller.
- Test only objects that have moved (against all objects)
- Sort all objects within bands?


-= Specific ideas for Configurtion tools =-
* Build links into setting variables that will trigger function calls
* Warn more gracefully if a variable/const name is used more than once?
* Build an HTML object to automatically allow adjustment of settings in a running ap.
* Allow other commands to redirect the rest of the line to a specific object for processing.
* Auto-generation of config file entries beyond just "set"
* Each setting could have a "level" value to indicate when it should be shouwn.
* See about uniting library user config file and end user config file into consistent format.
* Can we make the whole thing into just one macro?  Should we??

-= Documentation =-
* Examples using the web framework
* How to setup and use the config tools.
* Basic idea of Kinetic Wrappers and how to use them.

-= Librarys to consider wrapping =-
FabricJS
PaperJS -- VERY impressive demos!!  (PLUS best benchmarks next to native canvas)
oCanvas

http://www.graphdracula.net/  - build vertices & edges easily!
Box2D
Processing.JS
ChartJS
jqPlot
JQuery Sparklines -- Inline graphs

D3

-= Frameworks to consider wrapping =-
Ionic
Ember -- read strong arguments from developer; built to be practical in getting good aps fast.
